# 基本组成

源程序到可执行文件

IR指令寄存器

CU控制单元

MAR 地址寄存器 存放访存地址 用于寻址 位数对于存储单元的个数 长度与PC长度相等

MDR 数据寄存器 暂存要从存储器中读或写的信息 位数与存储字长相等




![执行流程.png (702×370) (jsdelivr.net)](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/执行流程.png)





![执行流程](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/执行流程.png)





指令和数据以同等地位存放在存储器里面，形式上无差别，只是在程序执行时具有不同的含义

指令按地址访问，数据由指令的地址码指出，除立即寻址外，数据均存在存储器内

在程序执行前，指令和数据需要预先存放在存储器中，中央处理器可以从存储器存取代码

计算机多层结构中，上下层是可以分割的，且上层是下层的实现功能实现，上层在下层的基础上实现了更加丰富的功能

编译程序是先完整的编译后运行程序，eg c ,c++ 解释程序是一句一句翻译且边翻译边执行的程序 如 js,python

犹豫解释程序要边翻译成机器语言边执行，一般速度较编译程序慢



多处理机的工作方式是多指令多数据流方式

冯诺依曼计算机基本工作方式是控制流驱动方式  本质特征是  存储程序原理

地址译码器是主存的构成部分

层次化，模块化，规则性



指令和数据都是保存在存储器中的



存储器基本组成

主存储器{存储体，MAR，MAR}

MAR 存储器地址寄存器（反应存储单元的个数）

MDR 存储器数据寄存器（反映存储字长）

![运算器](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/运算器基本组成.png)

存储体-存储单元-存储元件



**存储单元** 存放一串二进制代码

**存储字** 存储单元中的二进制代码组合

**存储字长** 存储单元中二进制的位数



控制器功能：解释指令，保证指令按序执行



控制器基本组成 CU（执行指令） PC（取指令） IR （分析指令）

取数流程

![取数流程](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/取数流程.png)

存数流程

![存数流程](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/存数流程.png)



机器字长 CPU一次能处理数据的位数与CPU中的寄存器位数有关



运算速度 

主频 核数（每个核支持的线程数） 吉普森算法

CPI 执行一条指令所需要的时钟周期数

MIPS 每秒执行百万条指令

FLOPS 每秒浮点运算次数



存储容量 存放二进制信息的总位数



存储容量

![存储容量](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/20220711165820.png)

## 电脑发展





# 第二章

## 字符

### 进制

十进制到任意进制 

整数部分 除基取余法

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/除基取余法.png)



乘基取整法（小数）

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/乘基取整法.png)



## 字符与字符串

ASCII码

- 32~126位称为可印刷字符
- A-Z，a-z是连续的，但是Z和a之间不连续
- 以字节的形式存储

>例：已知'A'的ASCII码码值是65，H存放在某存储单元M中，求M中存放的值
>
>65+(8-1)=72
>
>72 = 0100 1000

字符串

字符串：IF_ _A>B THEN READ(C) ，每个存储单元存放4B

**大端模式**：存储单元内**先存储高位字节**、**后存储低位字节**的顺序

**小端模式**：存储单元内**先存储低位字节**、**后存储高位字节**的顺序

### 汉字编码

包括输入的**输入编码**，计算机内部处理的**汉字内码**和输出的**汉字字形码**三种。



### 校验码

**码距**：任意两个合法码字之间不同的二进制的位数。

- 码距大于等于2时，开始具有检错能力
- 码距越大，纠错、检错能力越强

### 奇偶校验码

添加一个校验位，校验位的取值满足以下规定：

**奇校验码**：整个校验码（有效信息位和校验位）中“1”的个数为奇数。

**偶校验码**：整个校验码（有效信息位和校验位）中“1”的个数为偶数。

即在有效信息的前面添加1或者0即可。

### 海明校验码

- 若信息位的位数为n，海明码的位数为k ，则有：

(1)2k≥n+k+1

- 将校验位依次放在位于2i−1位上，并将信息位按照顺序填入剩下的位置
- 海明码的取值相当于将各数据位的第i组的所有位求异或
- 每个校验组分别用校验位和参与计算校验位的信息位进行奇偶校验，并得到响应结果。

例：求1010的海明码

**确定位数**

因为 n=4，则由（1）计算得 k=3

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/海明码.png)

**确定校验位的分布**

- 将校验码放在2i−1位置上

| H7   | H6   | H5   | H4   | H3   | H2   | H1   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      | P3   |      | P2   | P1   |

- 将信息位填入剩下的位置



| H7   | H6   | H5   | H4   | H3   | H2   | H1   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| D4   | D3   | D2   | P3   | D1   | P2   | P1   |
| 1    | 0    | 1    |      | 0    |      |      |



求校验位的值

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/海明码校验.png)



纠错

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/海明纠错.png)



**循环冗余校验**





## 定点数和有符号数

无符号

有符号数

原码

最高位表示符号位



补码

- 正数的补码：补码与原码相同

- 负数的补码：原码符号位不变，数值位取反，末位加1

- 当一个正数和一个负数互为补数时，他们的绝对值之和称为

  模数，类似于时钟，+2 = -10，12为模数

反码

正数的反码：反码与原码相同
负数的反码：原码符号位不变，数值位取反

移码

在真值X上加上一个常数（偏置值）

- 同一个数，补码和移码**只有符号位相反**
- 移码大真值就大，移码小真值就小
  - 移码全为0：−2n
  - 移码全为1：2n−1
- 移码的0唯一

## 定点数的运算

移位

算术移位

机器码采用有符号数，符号位不参与

- 正数
  - 空位补0
- 负数
  - 原码：0
  - 补码：
    - 左移：0
    - 右移：1
  - 反码：1



逻辑移位

机器码采用**无符号数**，直接补0。



循环移位

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/循环移位.png)



加减法

补码直接相加

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/补码例子.png)



溢出的概念和判断方式
大于机器所能表示的最大正数称为上溢；
小于机器所能表示的最小负数称为下溢。
当两个符号相同的数相加或者两个符号相异的数相减时才会发生溢出。



源码一位乘法















补码Booth乘法















定点数除法









## 浮点数表示和运算

N=power(r,e)*M

r为阶码的底，通常为2

e为阶码 反应浮点数表示范围和小数点的实际位置，用补码或者移码表示

m尾数其位数反映小数的精度 用原码或者补码表示



IEEE 754标准

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/IEEE754.png)



## 浮点数的运算

加减法

对阶，尾数加减，规格化，舍入，判溢出



















- 有符号数
  - OF：溢出标志位
    - 最高位产生的进位与次高位产生的进位异或
    - **判断有符号数的溢出**
  - SF：符号标志位
    - 取运算结果的最高位
- 无符号数
  - ZF：零标志位
    - 运算结果全部为零
  - CF：进位标志
    - 最高位的进位信号与sub进行异或
    - 为1代表发生了借位，产生溢出
    - 判断无符号数的溢出





# 存储器



![存储器层次化结构](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/存储器层次化结构.png)





存储器的分类--层次

高速缓存cache，主存储器（主存，内存），辅助存储器（辅存，外存）



CAM 相联存储器 ”快表“就是相联存储器

RAM随机存储器 

串行访问存储器：读写某个存储单元所需时间与存储单元物理位置无关

SAM顺序存储器

DAM直接存取存储器 既有随机存取特性也有顺序存取特性，先直接选取信息所在区域如何顺序方式存取



读写存储器和只读存储器ROM



信息可保存性

断电后消失的存储器 易失存储器（主存，cache）

断电后存储信息依然保持的存储器 非易失性存储器（磁盘，光盘）



信息读出后，原存储信息被破坏――破坏性读出（如DRAM芯片，读出数据后要进行重写)

信息读出后，原存储信息不被破坏――非破坏性读出（如SRAM芯片、磁盘、光盘)



存储器性能指标

存储容量：存储字数*字长 （如1M\*8位）  MDR位数反应存储字长

单位成本 每位价格=总成本/总容量

存储速度：数据传输率=数据的宽度/存储周期          数据的宽度即存储字长





①存取时间(Ta）:存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。
②存取周期(Tm):存取周期又称为读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作(读或写操作）之间所需的最小时间间隔。
主存带宽（Bm）:主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒(B/s）或位/秒（b/s） 。





总容量等于 存储单元的个数*存储字长



寻址 字节寻址

按字寻址

按半字寻址

按双字寻址

## 内存

DRAM（动态）和SRAM（静态）

区别存储元不一样，前者是栅极电容，后者是双稳态触发器

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/DRAM和SRAM.png)



DRAM的刷新

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/DRAM的刷新.png)





![只读存储器](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/ROM.png)



增加主存的存储字长-位扩展



字扩展

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/译码片选法.png)



MROM 掩模式只读存储器，生产过程直接写入，之后任何人不可重写

PROM 可编程只读存储器 写入一次后不可写入

EPROM 可进行多长重写

Flash Memory 闪速存储器 可进行多长快速擦除重写

SSD 固态硬盘



逻辑上 主存由RAM+ROM组成且二者常统一编址



线选法  n条线->n个选片信号  电路简单 地址空间不连续

译码片选法 n条线->2的n次方个选片信号 地址空间连续



字位同时扩展



双端口RAM

优化多核CPU访问一根内存条的速度

需要有两组完全独立的数据线，地址线，控制线,CPU,RAM中也要有更复杂的控制电路

发生冲突  发出BUSY信号，其中一个CPU的访问端口暂时关闭



**多体并行存储器**

高位交叉编址的多体存储器  体号|体内地址

理论上多个存储体并行访问，但是由于连续访问相当于扩容



低位交叉编址的多体存储器 体内地址|体号



当存储模块数m>=T/r时，可使流水线不间断，每个存储周期内可读写地址连续的m个字

微观上，m个模块被串行访问；宏观上，每个存储周期内所有模块被并行访问



存储周期T 存取时间r

存储周期T 总线传输周期为r



## 外存

外存储器

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/外存储器.png)



磁盘存储器

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/磁盘存储器.png)



性能指标

1 磁盘容量：一个磁盘所能存储的字节总数

非格式化容量是指磁记录表面可以利用的磁化单元总数

格式化容量指按照某种特定的记录格式所能存储信息的总量

2 记录密度：盘片单位面积记录的二进制的信息量

道密度是沿磁盘半径方向单位长度上的磁道数

位密度是磁道单位长度上能记录的二进制代码位数

面密度是位密度和道密度的乘积

3 平均存取时间

平均存取时间  = 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区的）+传输时间（传输数据所花费的时间）

4 数据传输率

磁盘存储器在单位时间内向主机传送数据的字节数



磁盘地址

主机向磁盘控制器发送寻址信息

驱动器号           |柱面（磁道）号             |盘面号               |扇区号          |

多个磁盘              移动磁头臂（寻道）     激活某个磁头   通过旋转将特定扇区划过磁头下方



硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。
硬盘属于机械式部件，其读写操作是串行，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/磁盘阵列.png)



![SSD](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/SSD.png)



## Cache

工作原理 （实际上，Cache被集成在CPU内部用SRAM实现，速度快，成本高）

时间局部性 在最近的未来要用到的信息，很可能是现在正在使用到的信息

空间局部性 在最近未来要用到的信息（指令和数据），很可能鱼现在在使用的信息存储空间上是邻近的



tc为访问Cache的时间 tm为访问主存的时间

命中率为H

缺失率（未命中率） M = 1-H

平均访问时间 t =Htc+（1-H)(tc+tm)  (Cache未命中则访问主存)

同时访问 t =Htc+(1-H)tm



主存与Cache之间以块位单位进行数据交换

操作系统中，通常将主存中的一个块也称为一个页/页面/页框

Cache中的块也称行



### Cache映射关系

全相联映射 

主存块可以放在Cache的任意位置

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/全相联.png)





直接映射

每个主存块只能放到一个特定的位置，Cache块号 = 主存块号%Cache总块数

若Cache总块数=2的n次方 则主存块号末尾n位直接反映它在cache中的位置

将主存块号的其余位作为标记即可





**组相联映射**

所属分组=主存块号%分组数

n路组相联映射 --每n个cache行为一组

2路组相联映射--2块位一组，分为4组

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/组相联访问.png)





Cache替换算法

随机算法RAND



先进先出算法FIFO

替换最先被调入cache块



近期最少使用LRU

为每个Cache设置一个计数器，用于记录每个Cache块已经有多久没有被访问

 

最近不经常使用LFU



![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/cache替换算法.png)



写回法

当CPU对Cache写命中是，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存

减少了访存次数，但存在数据不一致的隐患



全写法，当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲

访存次数增加，速度变慢，但能保证数据一致性



多级Cache





![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/cache写策略.png)



# 指令系统

指令

x86架构 arm架构

一条指令就是机器语言的一个语句



操作嘛（op）|地址码（A)

一条指令可以包含0，1，2，3，4.....个地址码



**零地址指令  OP**

1，不需要操作数，如空操作，停机，关中断等指令

2，堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，结果压会栈顶



**一地址指令  OP|A1**

1.只需要单操作数，如加1、减1、取反、求补等
指令含义：OP(A1)→A1， 完成一条指令需要3次访存：取指→读A1→写A1
2.需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）
指令含义：(ACC)OP(A1)->ACC
完成一条指令需要2次访存：取指→读A1



A1表示主存地址  （A1)表示A1所指向的地址中的内容



二地址指令 OP|A1（目的操作数）|A2（源操作数）

常用于需要两个操作数的算算运算，逻辑运算相关指令

完成一条指令需要访存4次  取指->读A1->读A2->写A1



三地址指令 OP|A1|A2|A3（结果）

常用于需要两个操作数的算术运算，逻辑运算相关指令

完成一条需要访存4次



四地址指令 op|A1|A2|A3(结果)|A4（下址）

完成需要访存4次 取指->读A1->读A2->写A3

正常情况下：取指令之后PC+1，指向下一条指令

四地址指令：执行指令后，将PC的值修改位A4所指的地址





指令字长：一条指令的总长度（可能会变）

机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关）

存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同）

半长指令，单字长指令，双字长指令

定长指令字结构



变长指令字结构



定长操作码：指令系统中所有指令的操作码长度都相同

n位就是pow（2，n）条指令



可变长操作码：指令系统中个指令的操作码长度可变



![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/指令操作类型.png)



## 扩展操作码

在设计扩展操作码时

不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分代码相同

各指令的操作码一定不能重复



地址长度位n，上一层留出m种状态，下一层可扩展出m*2的n次方种



## 指令寻址

按字编址

（pc）+1 ->pc

按字节编址

（pc) +2  ->pc



读入一个字，根据操作码判断这条指令的总字节数n，修改pc值



![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/寻址.png)



**直接寻址**

指令中的形式地址A就是操作数的真实地址EA  即EA=A

一条指令的执行  取指令 访存一次

执行指令 访存一次



**间接寻址**

间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A) 。

一次间接寻址需要两次访存，多次寻址需要根据存储字的最高位确定几次访存



**寄存器寻址**

寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即EA =Ri其操作数在由Ri,所指的寄存器内。

取指令 访存一次  执行指令访存0次



**寄存器间接寻址**

寄存器间接寻址：寄存器R中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(R) 。

一条指令的执行：取指令访存1次执行指令访存1次暂不考虑存结果共访存2次



**隐含寻址**

隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址 。



**立即寻址**

立即寻址：形式地址A就是操作数本身，又称为立即数，一般采用补码形式。#表示立即寻址特征。

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/寻址方式.png)



**基址寻址**

将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR)+A。

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/基址寻址.png)



**变址寻址**

变址寻址：有效地址EA等于指令字中的形式地址A与变址寄存器Ⅸ的1x的内容相加之和，即EA=(IX)+A，其中Ⅸ可为变址寄存器（专用），也可用通用寄存器作为变址寄存器。



**相对寻址**

相对寻址：把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=（PC）+A 其中A相对于pc所指地址的位移量可正可负，补码表示



![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/硬件如何实现比价.png)



**堆栈寻址**

操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址



入栈/出栈是EA的确定方式不同，硬堆栈不访存，软堆栈访存一次

x86架构CPU

EAX 

 EBX

 ECX

 EDX 

ESI 变址寄存器 I=Index S= Source D=Destineation

EDI

 EBP 堆栈基指针

 ESP 堆栈顶指针

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/汇编指令.png)



## 汇编指令



![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/汇编.png)



![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/不同格式汇编代码.png)



无条件转义指令jmp

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/条件转移指令.png)



OF 溢出标志  溢出时为1 否则置0

SF 符号标志 结果为负时置1，否则为0

ZF 0标志 运算结果为0时ZF位置为1否则为0

CF 进位/借位时置1 否则为0





循环语句



![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/cisc和risc.png)





# 中央处理器

运算器：用于实现算术运算（如：加减乘除），逻辑运算（如，与或非）

| 运算器基本组成                                               |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/运算器.png) | ACC： 累加器，用于存放操作数，或运算结果。<br/>MQ： 乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。<br/>X： 通用的操作数寄存器，用于存放操作数<br/>ALU： 算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算 |



| 控制器的基本组成                                             |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20220812143414617](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E6%8E%A7%E5%88%B6%E5%99%A8.png) | CU：控制单元，分析指令，给出控制信号<br/>IR：指令寄存器，存放当前执行的指令<br/>PC：程序计数器，存放下一条指令地址，有自动加1功能 |



## CPU功能和基本结构

### cpu的功能

1.指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
2.操作控制。一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
3.时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间
顺序提供应有的控制信号。
4.数据加工。对数据进行算术和逻辑运算。
5.中断处理。对计算机运行过程中出现的异常情况和特殊请求

### 运算器和控制器的功能和结构

运算器对数据进行加工

控制器 协调并控制计算机各部件执行程序的指令序列

基本功能包括取指令、分析指令、执行指令
取指令：自动形成指令地址；自动发出取指令的命令。

分析指令：操作码译码(分析本条指令要完成什么操作)；产生操作数的有效地址。

执行指令：根据分析指令得到的“操作命令”和“操作数地址”,形成操作信号控制序列，控制运算器、存储器以及I/O设备完成相应的操作。

中断处理：管理总线及输入输出；处理异常情况(如掉电）和特殊请求(如打印机请求打印一行字符)。



**运算器的基本结构**

1.算术逻辑单元：主要功能是进行算术/逻辑运算。

2.通用寄存器组：如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。

3.暂存寄存器：用于暂存从主存读来的数据这个数 据不能存放在通用寄存器中，否则会破坏其原有内容

4.累加寄存器：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算。
5.程序状态字寄存器：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志（OP）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。PSW中的这些位参与并决定微操作的形成。
6.移位器：对运算结果进行移位运算。
7.计数器：控制乘除运算的操作步数。

cpu内部单总线方式：将所有寄存器的输入端和输出端都连接到一条公共的通路上



多路选择器和三态门

**控制器基本结构**

![](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/控制器的基本结构.png)



![CPU回顾](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/cpu回顾.png)



## 数据通路

指令周期的数据流

数据通路：数据在功能部件之间传送的路径

基本结构：CPU内部单总线结构，CPU内部多总线结构，专用数据通路方式



由控制部件产生的控制信号建立数据通路



内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线

系统总线是指同一台计算机系统的各个部件，如CPU，内存，通道和各类I/O接口间互相连接的总线

1.寄存器之间的数据传送

2.主存与CPU之间的数据传送

3.执行算术或逻辑运算



![image-20220812152358326](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E5%86%85%E9%83%A8%E5%8D%95%E6%80%BB%E7%BA%BF.png)



与主存相连的寄存器是MAR和MDR  

解题基本思路

寄存器之间的数据传送，主存和CPU之间的数据传送，使用ALU进行算术逻辑运算

基本思路，利用题目提供的数据通路进行数据传送

有CU发出控制信号实现通路的建立



![image-20220812153459610](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E5%BE%AE%E6%93%8D%E4%BD%9C.png)



![image-20220812153559494](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8.png)



硬布线控制器

1.分析每个阶段的微操作序列（取值，间址，执行，中断 四个阶段）

2.选择CPU控制方式

3.安排微操作时序

原则（1，先后顺序不得随意更改，2，被控对象不同的微操作尽量安排在一个节拍内完成，占用时间较短的微操作尽量安排在一个节拍内完成，并运行有先后顺序）

4.电路设计 (确定每个微操作命令的逻辑表达式，并用电路实现)



## 微程序



## 指令流水

一条指令的执行过程

取指：根据PC内容访问主存储器，取出一条指令送到IR中。
分析：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA，并从有效地址EA中取出操作数。
执行：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。

顺序执行方式

总耗时T=n*3t = 3nt 

传统冯洛依曼机采用顺序执行方式，串行执行方式

控制简单，硬件代价小

一次重叠执行方式

T=（1+2n）t

二次重叠方式

T = (2+n)t

指令执行过程图

时空图



流水线的性能指标

吞吐率 吞吐率是指在单位时间内流水线所完成的任务数量

设任务位n，处理完成n个任务所用的时间为Tk

则流水线吞吐率 TP=n/Tk



![image-20220812155220001](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/image-%E5%90%9E%E5%90%90%E7%8E%87.png)



加速比

![image-20220812155319965](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8A%A0%E9%80%9F%E6%AF%94.png)



![image-20220812160422239](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%95%88%E7%8E%87.png)



硬件多线程

细粒度多线程，粗粒度多线程，同时多线程（SMT）

![image-20220812160937704](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B.png)



## 指令执行过程

![image-20220812161033919](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png)



四个工作周期都有CPU访存操作，只是访存的目的不同。取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。



![image-20220812161201410](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png)

![image-20220812161231427](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F.png)



![image-20220812161259207](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png)



![image-20220812161501968](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88.png)





# 系统总线

总线是连接各个部件的信息传输线是各个部件共享的传输介质



串行总线 并行总线

单总线 

CPU双总线

存储双总线



## 总线分类

片总线  芯片内部的总线

系统总线

计算机各部件之间的信息传输线 （数据总线（双向，与机器字长，存储字长有关）,地址总线（单向，与存储地址，I/O地址有关），控制总线  （有出（中断请求，总线请求）有入（存储器读，存储器写，总线允许，中断缺人）））



通信总线

用于计算机系统之间或计算机系统与其它系统之间的通信

传输方式有串行和并行



## 总线特性 性能指标

### 特性



机械特性  尺寸，形状，管脚数，排列顺序

电气特性 传输方向和有效电平范围

功能特性   每根传输线的功能（地址，数据，控制）

时间特性 信号和时序关系



### 总线的性能指标

总线的宽度  数据线的根数

标准传输率 每秒传输的最大字节数（MBps）

时钟同步/异步  同步，不同步

总线复用 地址线与数据线复用

信号线数  地址线、数据线和控制线的总和

总线控制方式 突发、 自动、 仲裁、逻辑、计数

其它 负载能力



总线的传输周期（总线周期）

一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段），通常由若干个总线时钟周期构成。

总线的时钟周期

即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。

总线的工作频率

总线上各种操作的频率，为总线周期的倒数。若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。实际上指一秒内传送几次数据。

总线的时钟频率

即机器的时钟频率，为时钟周期的倒数。数量若时钟周期为T，则时钟频率为1/T。实际上指一秒内有多少个时钟周期。

总线宽度

又称为总线位宽，它是总线上同时能够传输的数据位数，通常是指数据总线的根数，如32根称为32位（bit）总线。

总线带宽

可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。

总线带宽=总线工作频率×总线宽度（bit/s）=总线工作频率×(总线宽度/8)（B/s）
总线宽度/总线周期(bit/s)=总线宽度/8/总线周期(B/s)
注：总线带宽是指总线本身所能达到的最高传输速率。
在计算实际的有效数据传输率时，要用实际传输的数据量除以耗时。



##  //(非408)总线标准



<img src="https://cdn.jsdelivr.net/gh/smartdoublej/note-img/总线标准.png" alt="总线标准" style="zoom:50%;" />



## 总线结构



单总线结构

<img src="https://cdn.jsdelivr.net/gh/smartdoublej/note-img/单总线结构.png" alt="单总线结构" style="zoom:50%;" />



多总线结构

<img src="https://cdn.jsdelivr.net/gh/smartdoublej/note-img/双总线.png" alt="双总线" style="zoom:50%;" />



三总线结构

<img src="https://cdn.jsdelivr.net/gh/smartdoublej/note-img/三总线结构.png" alt="三总线结构" style="zoom:50%;" />



<img src="https://cdn.jsdelivr.net/gh/smartdoublej/note-img/三总线2.png" alt="三总线2" style="zoom:50%;" />





<img src="https://cdn.jsdelivr.net/gh/smartdoublej/note-img/四总线.png" alt="四总线" style="zoom:50%;" />



<img src="https://cdn.jsdelivr.net/gh/smartdoublej/note-img/多层pci总线结构.png" alt="多层pci总线结构" style="zoom:50%;" />





##  总线操作和定时

![image-20220812162542186](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E6%80%BB%E7%BA%BF%E4%BC%A0%E8%BE%93%E7%9A%844%E4%B8%AA%E9%98%B6%E6%AE%B5.png)



![image-20220812162622865](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E5%90%8C%E6%AD%A5%E5%AE%9A%E6%97%B6%E8%AF%BB%E5%91%BD%E4%BB%A4.png)



![image-20220812162706817](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E5%BC%82%E6%AD%A5%E5%AE%9A%E6%97%B6%E9%80%9A%E4%BF%A1.png)



![image-20220812162742690](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1.png)



![image-20220812162810447](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E5%88%86%E7%A6%BB%E5%BC%8F.png)



# 输入输出系统

I/O接口，I/O控制器，设备控制器，负责协调主机和外部设备之间的数据传输

![image-20220812163222268](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/IO%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png)



DMA控制方式

![image-20220812163141299](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/DMA%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png)



通道控制方式

通道是具有特殊功能的处理器，能对IO设备进行统一的管理

## 基本组成

![image-20220812163402425](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/io%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png)



## 设备

显示屏，灰度级 n位可以表示2的n次方种不同的亮度或者颜色

容量=分辨率x灰度级位数
带宽=分辨率ⅹ灰度级位数*帧频



![image-20220812163951975](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E7%BB%9F%E4%B8%80%E7%BC%96%E5%88%B6.png)



![image-20220812164017511](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E7%BB%9F%E4%B8%80%E5%92%8C%E7%8B%AC%E7%AB%8BIO.png)



内部接口和外部接口

![image-20220812164124450](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/IO%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png)



独占查询和定时查询

![image-20220812164351621](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB.png)

中断响应，中断请求，中断处理

中断优先级

1.硬件故障中断属于最高级，其次是软件中断；
2.非屏蔽中断优于可屏蔽中断；
3.DMA请求优于I/O设备传送的中断请求
4.高速设备优于低速设备；
5.输入设备优于输出设备；
6.实时设备优于普通设备。



中断隐指令的主要任务

①关中断。在中断服务程序中，为了保护中断现场（即CPU主要寄存器中的内容）期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。
②保存断点。为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即程序计数器（PC）的内容）保存起来。可以存入堆栈，也可以存入指定单元。
③引出中断服务程序。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC）



中断服务程序

中断服务程序的主要任务：
①保护现场保存通用寄存器和状态寄存器的内容（eg：保存ACC寄存器的值），以便返回原程序后可以恢复CPU环境。可使用堆栈，也可以使用特定存储单元。
② 中断服务(设备服务)
主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中（eg：中断服务的过程中有可能修改ACC寄存器的值）
③恢复现场
通过出栈指令或取指令把之前保存的信息送回寄存器中（eg：把原程序算到一般的ACC值恢复原样）
④中断返回
通过中断返回指令回到原程序断点处。



![image-20220812170056268](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/%E5%8D%95%E4%B8%AD%E6%96%AD%E9%B1%BC%E5%A4%9A%E9%87%8D%E4%B8%AD%E6%96%AD.png)



中断屏蔽技术

中断屏蔽字

屏蔽字设置的规律：
1.一般用'1表示屏蔽，"表示正常申请。
2.每个中断源对应一个屏蔽字（在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字)。
3.屏蔽字中*1越多，优先级越高。每个屏蔽字中至少有一个1’(至少要能屏蔽自身的中断)。



程序执行轨迹



![image-20220812170405878](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/DMA%E6%96%B9%E5%BC%8F%E5%92%8C%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.png)



![image-20220812170536019](https://cdn.jsdelivr.net/gh/smartdoublej/note-img/DMA%E4%BC%A0%E9%80%81%E6%96%B9%E5%BC%8F.png)

DMA方式具有下列特点：
①它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。
②在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。
③主存中要开辟专用缓冲区，及时供给和接收外设的数据。
④ DMA传送速度快，CPU和外设并行工作，提高了系统效率。
DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。
