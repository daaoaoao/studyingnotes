

# 动态规划

1，穷举法/暴力搜索

2，记忆化搜索/剪枝

3.迭代的形式来写

动规的五部曲：

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 以最长递增子序列为例

```c++
//解法1
    
```



1.定义数组含义

2.找出**数组元素之间的关系式**

3.找出初始值 确定关系式

例题 青蛙跳台阶 一次 只能1或2

例题 二维一点到另外一点

斐波那契

```c++
int fib(int n) {
    if (n == 0 || n == 1) {
        // base case
        return n;
    }
    // 分别代表 dp[i - 1] 和 dp[i - 2]
    int dp_i_1 = 1, dp_i_2 = 0;
    for (int i = 2; i <= n; i++) {
        // dp[i] = dp[i - 1] + dp[i - 2];
        int dp_i = dp_i_1 + dp_i_2;
        // 滚动更新
        dp_i_2 = dp_i_1;
        dp_i_1 = dp_i;
    }
    return dp_i_1;
}
空间复杂度为1
```

# 带花费爬楼梯问题

[746. 使用最小花费爬楼梯 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

首先根据动态规划的思想来确定步骤

当爬上一个楼梯时候对应相应的体力值，

1，定义动态规划的数组

dp[i]到达第i阶楼梯所花费最小的体力

2，确定递推的公式

3，dp数组的初始化

4，确定遍历的顺序、

具体代码如下

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size()+1,0);
        dp[0]=cost[0];
        dp[1]=cost[1];
        for(int i=2;i<cost.size();i++)
        {
            dp[i]=min(dp[i-1],dp[i-2])+cost[i];
        }
        return min(dp[cost.size()-1],dp[cost.size()-2]);
    }
};
```

对于题目的意思来说，最后一步是不消费的体力的，所以取值就是在倒数第一第二中取最小值

因为一次是一步或者两步





# 凑零钱问题

```c++
int coinChange(int[] coins,int amount);
```

## 暴力递归

```c++
//不带备忘录的写法
int coinChange(int[] coins, int amount) {
    // 题目要求的最终结果是 dp(amount)
    return dp(coins, amount)
}
// 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币
int dp(int[] coins, int amount) {
    // base case
    if (amount == 0) return 0;
    if (amount < 0) return -1;
    int res = Integer.MAX_VALUE;
    for (int coin : coins) {
        // 计算子问题的结果
        int subProblem = dp(coins, amount - coin);
        // 子问题无解则跳过
        if (subProblem == -1) continue;
        // 在子问题中选择最优解，然后加一
        res = Math.min(res, subProblem + 1);
    }
    return res == Integer.MAX_VALUE ? -1 : res;
}
时间复杂度为(k*n^k)
//带备忘录的写法
int[] memo;
int coinChange(int[] coins, int amount) {
    memo = new int[amount + 1];
    // dp 数组全都初始化为特殊值
    Arrays.fill(memo, -666);
    return dp(coins, amount);
}
int dp(int[] coins, int amount) {
    if (amount == 0) return 0;
    if (amount < 0) return -1;
    // 查备忘录，防止重复计算
    if (memo[amount] != -666)
        return memo[amount];

    int res = Integer.MAX_VALUE;
    for (int coin : coins) {
        // 计算子问题的结果
        int subProblem = dp(coins, amount - coin);
        // 子问题无解则跳过
        if (subProblem == -1) continue;
        // 在子问题中选择最优解，然后加一
        res = Math.min(res, subProblem + 1);
    }
    // 把计算结果存入备忘录
    memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
    return memo[amount];
}
```

## dp数组的迭代解法

```c++
int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    // 数组大小为 amount + 1，初始值也为 amount + 1  去正数最大值会导致dp[i-coin]+1溢出
    Arrays.fill(dp, amount + 1);
    // base case
    dp[0] = 0;
    // 外层 for 循环在遍历所有状态的所有取值
    for (int i = 0; i < dp.length; i++) {
        // 内层 for 循环在求所有选择的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) {
                continue;
            }
            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}

```

# 最长递增子序列

定义dp数组  

![image-20220324130312505](../img/image-20220324130312505-16480981938951.png)

假设到nums数组的第几号元素 dp记录就是截止到这个元素递增的序列

**递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的子序列长度加一**

```c++
int lengthOfLIS(int[] nums) {
    // 定义：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
    int[] dp = new int[nums.length];
    // base case：dp 数组全都初始化为 1
    Arrays.fill(dp, 1);
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) 
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
    int res = 0;
    for (int i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}

```

题目  俄罗斯套娃信封问题

给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 `i` 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算 **最多能有多少个** 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

**注意**：不允许旋转信封。

我的解法

```c++
class Solution {
public:
    static bool cmp(vector<int>& a,vector<int>&b)
    {
        if(a[0]!=b[0])return a[0]<b[0];
        else return a[1]>b[1];
    }
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        sort(envelopes.begin(),envelopes.end(),cmp);
        int n=envelopes.size();
        vector<int> dp(n,1);
        for(int i=0;i<n;++i)
        for(int j=0;j<i;++j)
        {
            if(envelopes[i][1]>envelopes[j][1])dp[i]=max(dp[i],dp[j]+1);
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```



```c++
解题思路
先按照宽度排序，递增，宽度相同，高度递减排序
    
 int maxEnvelopes(vector<vector<int>>& envelopes){
        if(envelopes.empty())return 0;
      //先按w排序，若w相同，则按h由高到低排序；若w不同，则按w由小到大排序
        sort(envelopes.begin(),envelopes.end(),[](const auto& a,const auto& b){
            return a[0]<b[0]||(a[0]==b[0]&&a[1]>b[1]);
        });
        vector<int> dp;
        for(auto& en:envelopes){
            int idx=lower_bound(dp.begin(),dp.end(),en[1])-dp.begin();
            if(idx>=dp.size()){
                dp.emplace_back(en[1]);
            }
            else{
                dp[idx]=en[1];
            }
        }
        return dp.size();
```

# 最大连续子序列和

问题一

```c++
/*
Problem Description
给定K个整数的序列{ N1, N2, ..., NK }，其任意连续子序列可表示为{ Ni, Ni+1, ..., 
Nj }，其中 1 <= i <= j <= K。最大连续子序列是所有连续子序列中元素和最大的一个， 
例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和 
为20。 
在今年的数据结构考卷中，要求编写程序得到最大和，现在增加一个要求，即还需要输出该 
子序列的第一个和最后一个元素。
Input
测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( < 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。
Output
对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元 
素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。 
Sample Input
6
-2 11 -4 13 -5 -2
10
-10 1 2 3 4 -5 -23 3 7 -21
6
5 -8 3 2 5 0
1
10
3
-1 -5 -2
3
-1 0 -2
0
Sample Output
20 11 13
10 1 4
10 3 5
10 10 10
0 -1 -2
0 0 0 (最后一组数据有误)
*/
#include <iostream>
using namespace std;
int main()
{
    int a[200] = {0};   // 数组a记录整数序列
    // count记录负数个数
    // max 最大和  max_f 最大和最前端 max_l最大和最后端
    int n, i, j, s, count, max, max_f, max_l; 

    // 以输入作为循环条件实现多组数据的输入 
    while(cin>>n) {
        if( n == 0 ) return 0;
        // 特殊情况的判断
        count = 0;
        for( i = 0; i < n; ++i ) {
            cin>>a[i];
            if( a[i] < 0 ) count++;     //记录负数个数 
        }
        if(count == n) {
            max = 0;
            max_f = a[0];
            max_l = a[n-1];
        }
        // 大多数情况的操作
        else {
            max = a[0];max_f = a[0];max_l = a[0];
            for( i = 0; i < n; ++i ) {           
                //从a[0]开始计算各情况    
                s = a[i];
                // 算法 可草稿推演
                for( j = i+1; j < n; ++j ) {
                    s += a[j];
                    //寻找最大 
                    if(s>max) {                     
                        max = s; 
                        max_f = a[i];
                        max_l = a[j];
                    }
                }
            }
        }
        // 输出结果
        cout<<max<<" "<<max_f<<" "<<max_l<<endl;
    }
    return 0;
}

```

解法二

```c++
// 空间复杂度优化：dp[i]依赖于dp[i - 1],dp数组可使用一个变量作为替代
// 状态:dp[i]:以第i个数结尾的和的最大值
// 转移:若dp[i - 1] < 0,则以第i个数结尾的和的最大值为第i个数本身
//      若dp[i - 1] > 0,则以第i个数结尾的和的最大值为第dp[i - 1]与dp[i - 1] + nums[i]中的较大者
//      for循环中每次使用if分支进行判断，可合并为一句dp[i] = max(dp[i - 1] + nums[i], nums[i]);
// 避免遍历dp数组，每次比较dp更新结束后比较res与dp[i]的大小作为返回值
class Solution {
public:
    int maxSubArray(vector<int>& nums) 
    {
        int len = nums.size();
        int dp = nums[0];
        int res = nums[0];
        
        for(int i = 1; i < len; ++i)
        {
            dp = max(dp + nums[i], nums[i]);
            res = max(res, dp);
        }
        return res;
    }
};
```



# 编辑距离问题

![img](../img/title-16485358857072.png)

## 解题思路

给定两个字符串只能用三种操作把s1变成s2，求出最小的操作数

## 代码解析

定义两个指针i,j如何j走完s2时i没有走完s1删除操作删除s1缩短到s2

如果i走完了s1时j还没有走完s2那就只能用插入操作把s2剩下的字符全部插入到s1



# 最优子集

