文件操作

file.rdbuf()

rdbuf()实现一个流对象指向的内容用另外一个流对象来输出



在创建文件流时，可以显示指定它的打开方式为ios::binary，也就是以二进制方式打开。



c++在不同模块(源文件）里面定义的全局变量不保证构造顺序，但保证在同一模块里面定义的全局变量，按定义的先后顺序构造，按定义相反次序析构

如果全局变量有依赖关系，那么就把它们放在同一个源文件定义，且按正确的顺序定义，确保依赖关系正确，而不是定义在不同源文件；对于系统中的单件，单件依赖也要注意这个问题。

从安全的角度出发，定义变量的时候赋初值是一个好的习惯，很多错误皆因未正确初始化而起，C++11支持成员变量定义的时候直接初始化，成员变量尽量在成员初始化列表里初始化，且要按定义的顺序初始化。



# 严格弱排序

## 严格弱序的三条要求

1. 两个关键字不能同时“严格弱序”于对方
2. 如果a“严格弱序”于b，且b“严格弱序”于c，则a必须“严格弱序”于c
3. 如果存在两个关键字，**任何一个都不“严格弱序”于另一个**，则这两个关键字是相等的。



- 非自反性
- 非对称性
- 传递性

尽量对索引或者指针sort，而不是针对对象本身，因为如果对象比较大，交换（复制）对象比交换指针或索引更耗费。



# vector底层实现

(a) vector是动态扩容的，2的次方往上翻，为了确保数据保存在连续空间，每次扩充，会将原member悉数拷贝到新的内存块；不要保存vector内对象的指针，扩容会导致其失效 ；可以通过保存其下标index替代。 

(b) 运行过程中需要动态增删的vector，不宜存放大的对象本身 ，因为扩容会导致所有成员拷贝构造，消耗较大，可以通过保存对象指针替代。

(c)resize()是重置大小；reserve()是预留空间，并未改变size()，可避免多次扩容；clear()并不会导致空间收缩 ，如果需要释放空间，可以跟空的vector交换，std::vector <t>.swap(v)，c++11里shrink_to_fit()也能收缩内存。

(d) 理解at()和operator[]的区别 ：at()会做下标越界检查，operator[]提供数组索引级的访问，在release版本下不会检查下标，VC会在Debug版本会检查；c++标准规定:operator[]不提供下标安全性检查。

(e)C++标准规定了std::vector的底层用数组实现，认清这一点并利用这一点。

【6】用c标准库的安全版本（带n标识）替换非安全版本，比如用strncpy替代strcpy，用snprintf替代sprintf，用strncat代替strcat，用strncmp代替strcmp，memcpy(dst, src, n)要确保[dst，dst+n]和[src, src+n]都有有效的虚拟内存地址空间。；多线程环境下，要用系统调用或者库函数的安全版本代替非安全版本（_r版本），谨记strtok，gmtime等标准c函数都不是线程安全的

【7】理解函数调用的性能开销（栈帧建立和销毁，参数传递，控制转移），性能敏感函数考虑inline

X86_64体系结构因为通用寄存器数目增加到16个，所以64位系统下参数数目不多的函数调用，将会由寄存器传递代替压栈方式传递参数，但栈帧建立、撤销和控制转移依然会对性能有所影响。







用sprintf格式化字符串的时候，类型和格式化符号要严格匹配，因为sprintf的函数实现里是按格式化串从栈上取参数，任何不一致，都有可能引起不可预知的错误； /usr/include/inttypes.h里定义了跨平台的格式化符号，比如PRId64用于格式化int64_t





标准库给出了最好的示范，因为如果是有符号的话，你需要这样判断

if (index < 0 || index >= max_num) throw out_of_bound();

而如果是无符号整数，你只需要判断 if (index >= max_num)



第三方库开发

[推荐几个开源库 (qq.com)](https://mp.weixin.qq.com/s/LSy4fnWKMEln7v9QO-aeZA)

