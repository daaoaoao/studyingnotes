

>参考链接
>
>[一文让你搞懂设计模式 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484791&idx=1&sn=82ec021524713d413722f8a70e995917&source=41#wechat_redirect)



创建型模式，共五种：**工厂方法模式、抽象工厂模式**、**单例模式**、建造者模式、**原型模式。**

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

[TOC]





# 简介

理解隔离变化

​	宏观层面看，面对对象的构建方式更能适合软件的变化，将变化带来的影响减为最小

各司其职

​	从微观层面来看，面对对象的方式更强调各个类的责任

​	由于需求变化导致的新增类型不应该影响原来类型的实现

对象？

​	语言层面 对象封装代码和数据

​	规格，对象一系列可被使用的公共接口

​	概念，对象是某种拥有责任的抽象









# 设计原则

## 单一职责原则

Single responsibility principle 

应该有且仅有一个原因引起类的变更



好处

类的复杂性降低了，实现什么职责都有明确的定义

可读性提高，复杂性降低

可维护性提高，可读性提高

变更引起的风险降低，变更是比不可少的



单一职责原则  职责和变化原因都是不可度量的，因项目而异，因环境而异







## 里氏替换原则



**继承优点**

代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性

提高代码的重用性

提高可扩展性

提高产品或者项目的开放性

**缺点**

继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法：

降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；

增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果一大段的代码需要重构。



只有父类出现的地方子类就可以出现，而且替换为子类不会出现问题。

里氏替换只能正着用不能反用

### 子类必须完全实现父类的方法



### 子类可以有自己的个性



### 覆盖或者实现父类的方法时输入的参数可以被放大



### 覆盖或者实现父类的方法时输入的参数可以被缩小



在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的个性”被抹杀一一委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离一缺乏类替换的标准。





## 依赖倒置原则

高层模块不应该依赖低层模块，两者都应该依赖其抽象

抽象不应该依赖细节

细节应该依赖抽象

可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性







## 接口隔离原则



## 迪米特原则



## 开闭原则

OCP

对扩展开放，对更改封闭

类模块应该是可扩展的，但是不可修改的





## 接口隔离原则

ISP

不应该强迫客户程序依赖它们不用的方法

接口预告小而完备



## 原则

优先使用对象组合，而不是类的继承

类继承通常为白箱复用，对象组合通常为黑箱复用

继承在某种程度上破坏了封装性，子类父类耦合度高

而对象组合则只要求被组合对象具有良好定义的接口，耦合度低



## 封装变化点

使用封装来创建对象之间的分界层，让设计者可以在分界层的 一侧进行修改，而不会对另一侧产生不良的影响，从而实现层 次间的松耦合



## 针对接口编程，而不是针对实现编程

不将变量类型声明为某个特定的具体类，而是声明为某个接口

客户程序无需获知对象的具体类型，只需要知道对象所具有的接口

减少系统中各个部分的依赖关系，高内聚，松耦合



目的来看：

创建型模式：将对象的部分创建工作延迟到子类或者其他对象，应对需求变化为对象创建时具体类型实现引来的冲击

结构性模式：通过类继承或者对象组合获得更灵活的结构，应对需求变化为对象的结构带来的冲击

行为型模式：通过类继承或者对象组合来划分类与对象间的责任，应对需求变化为多个交互对象带来的冲击

范围：

类模式处理类与子类的静态关系

对象模式处理对象间的动态关系





# 重构关键技法

静态-> 动态

早绑定-> 晚绑定

继承-> 组合

编译时依赖-> 运行时依赖

紧耦合-> 松耦合



# Template Method 模式

## 动机（Motivation)

在软件构建过程中，对于某一项任务，常常有稳定的整体操作结构，但是各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架和应用之间的关系）而无法和任务整体结构同时实现



## 要点

Template Method 模式是一种非常基础性的设计模式。在面向对象系统中有大量的应用，简洁的机制（虚函数的多态性）为很多应用程序框架提供灵活的扩展点，是代码复用方面的基本实现结构

在具体实现方面，被 Template Method 调用的虚方法可以具有实 现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将 它们设置为 protected 方法。







# 策略模式

可以降低耦合

策略模式 定义算法家族，之间可以互相替换，让算法变化，不会影响使用算法的客户

是一种定义一系列算法的方法，从概念上来看，算法完成的工作相同，实现不同，可以以相同的方式调用所有算法，减少各种算法类与使用算法类之间的耦合

策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性

定义一系列的算法，将它们一个个封装，使得他们可以相互替换，一般为了解决多个 if-else 带来的复杂性，在多种算法相似的情况下，通过策略模式可减少 if-else 带来的复杂性和难以维护性，一般在项目中发现多个 if-else 并且预感将来还会在此增加 if-else 分支，那基本上就需要使用策略模式。
先举一个不使用策略模式的例子，拿计算来说，下面代码定义了加法操作和减法操作，以后如果需要增加乘法除法等计算，那就需要在枚举里添加新类型，并且增加 if-else 分支，这违反了开放关闭原则。

`< |--` 表示继承

`+` 表示 public

`-` 表示 private

`- > >` 表示实线

`-->>` 虚线

`[*]` 表示开始或者结束，如果在箭头右边则表示结束。

- 饼状图：使用 `pie` 关键字，具体用法后文将详细介绍
- 流程图：使用 `graph` 关键字，具体用法后文将详细介绍
- 序列图：使用 `sequenceDiagram` 关键字
- 甘特图：使用 `gantt` 关键字
- 类图：使用 `classDiagram` 关键字
- 状态图：使用 `stateDiagram` 关键字
- 用户旅程图：使用 `journey` 关键字

![image-20230208142012285](./img/image-20230208142012285.png)

Strategy 及其子类为组件提供一系列可重用算法，使类型在运行时方便地根据需要在算法之间进行切换

在 Strategy 对象没有实例变量情况下，上下文可以共享



































# 简单工厂模式

## 适用情况

当产品数目不多，而且逻辑简单得的时候

## 优缺点

逻辑简单

违背开闭原则，每次都要修改代码

# 抽象工厂模式

**适用情况**

例如需要读文件，文件类型都是 txt，但是文件有 3 列的、6 列的格式，以后还会有其他格式的；或者设计一个物流类，有水路的、陆路的、以后还会有空航；这些需要很多不同类的情况，以后可能还要添加新的类的情况，一般初期会考虑工厂模式

**优缺点**

优点：你可以确保同一工厂生成的产品相互匹配。符合单一职责原则和开闭原则
缺点：由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂

**与其他模式关系**

- 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。
- 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。
- 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。
- 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。
- 你可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。
- 抽象工厂、 生成器和原型都可以用单例模式来实现。





# 单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**注意：**

- 1、单例类只能有一个实例。
- 2、单例类必须自己创建自己的唯一实例。
- 3、单例类必须给所有其他对象提供这一实例。



## 介绍

**意图：** 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：** 一个全局使用的类频繁地创建与销毁。

**何时使用：** 当您想控制实例数目，节省系统资源的时候。

**如何解决：** 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：** 构造函数是私有的。

**应用实例：**

- 1、一个班级只有一个班主任。
- 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
- 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

**优点：**

- 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 2、避免对资源的多重占用（比如写文件操作）。

**缺点：** 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**使用场景：**

- 1、要求生产唯一序列号。
- 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
- 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

**注意事项：** getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。



### 什么是单例

- 保证一个类只有一个实例，并且提供一个访问该全局访问点

### 2.那些地方用到了单例模式

1. 网站的计数器，一般也是采用单例模式实现，否则难以同步。
2. 应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。
3. 多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控制
4. Windows 的（任务管理器）就是很典型的单例模式，他不能打开俩个
5. windows 的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例。







# 观察者模式

## 适用情况

订阅和通知

优点：符合开闭原则，无需修改就可以添加新的订阅者
缺点：订阅者的通知顺序时随机的

## **模式关键点**

观察者需要两个抽象类
一个是发布者 subject，需要实现添加订阅、删除订阅、通知的功能
另一个是订阅者 observer，起码要实现一个响应功能 update



定义对象间的一对多关系，当一个对象状态发生改变的时候，其它依赖于它的对象都会得到广播通知并进行自定义动作，通过面向对象技术的多态技术，可以降低依赖关系，降低耦合度

![image-20230208142413974](./img/image-20230208142413974.png)

目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播

观察者自己决定是否需要订阅通知，目标对象对此一无所知

参考 QT 事件  UI 框架  MVC









# 装饰器模式

## 适用情况

假如你已经开发了 n 个功能类，然后你需要在这 n 个类的基础上，一个类负责一个功能，分别为读、写、修改，拓展 m 功能，如加密，需要构建为读加密、写加密、修改加密这 m*n 个类，如果 m 和 n 的数量很大，子类数量将爆炸

假设你正在开发一个提供通知功能的库， 其他程序可使用它向用户发送关于重要事件的通知。

库的最初版本基于 通知器 Notifier 类， 其中只有很少的几个成员变量， 一个构造函数和一个 send 发送方法。 该方法可以接收来自客户端的消息参数， 并将该消息发送给一系列的邮箱， 邮箱列表则是通过构造函数传递给通知器的。 作为客户端的第三方程序仅会创建和配置通知器对象一次， 然后在有重要事件发生时对其进行调用。



此后某个时刻， 你会发现库的用户希望使用除邮件通知之外的功能。 许多用户会希望接收关于紧急事件的手机短信， 还有些用户希望在微信上接收消息， 而公司用户则希望在 QQ 上接收消息。



这有什么难的呢？ 首先扩展 通知器类， 然后在新的子类中加入额外的通知方法。 现在客户端要对所需通知形式的对应类进行初始化， 然后使用该类发送后续所有的通知消息。

但是很快有人会问：  “为什么不同时使用多种通知形式呢？ 如果房子着火了， 你大概会想在所有渠道中都收到相同的消息吧。”

你可以尝试创建一个特殊子类来将多种通知方法组合在一起以解决该问题。 但这种方式会使得代码量迅速膨胀， 不仅仅是程序库代码， 客户端代码也会如此。



其实之前的设计模式原则里有一条，组合优于继承，对于拓展的继承会产生数量巨大的类，可以尝试使用组合



## **优缺点**

优点：你无需创建新子类即可扩展对象的行为、编译时拓展变成运行时拓展、
缺点：代码有些难以理解、在封装器栈中删除特定封装器比较困难









动态的给一个对象添加一些额外的职责，扩展一个类的功能，就增加功能来说，使用装饰器模式比单纯的继承子类更加灵活，不一定非要疯狂使用继承方式。
举个例子，有游戏这个大类，扩展这个类的功能，有打篮球，踢足球，玩 lol，玩卡丁车，可以分别定义继承游戏基类的四个子类，但是如果想组合这几个功能呢，一个对象既会打篮球又会玩卡丁车，既会打篮球又会玩 lol，再定义几个类继承游戏基类显然不是好的做法，装饰器模式可以很好的解决这个问题



解决扩展问题



# 模板模式



## **适用情况**

假如你正在开发一款分析公司文档的数据挖掘程序。 用户需要向程序输入各种格式 （PDF、 DOC 或 CSV） 的文档， 程序则会试图从这些文件中抽取有意义的数据， 并以统一的格式将其返回给用户。

该程序的首个版本仅支持 DOC 文件。 在接下来的一个版本中， 程序能够支持 CSV 文件。 一个月后， 你 “教会” 了程序从 PDF 文件中抽取数据。一段时间后， 你发现这三个类中包含许多相似代码。

尽管这些类处理不同数据格式的代码完全不同， 但数据处理和分析的代码却几乎完全一样，将相同部分代码提取成接口，使用多态性实现个性化，是模板模式的精髓

## **优缺点**

优点：可以重写某个算法的特定部分，分离相同部分
缺点：违反里氏替换原则，子类不能完全替换基类；当算法步骤需要修改时，需要修改所有的类





# 桥接模式

确定好抽象部分和实现部分，将抽象部分和实现部分分离，使得他们可以独立的变化，实现系统和抽象系统可能各自都会有各自的变化，使用桥接模式可以更加灵活的扩展，方法：用组合代替继承。
举例：一个图形基类，可以有圆形矩形多边形等等，每个都需要从图形基类中继承出一个子类，但是每个子类还需要画图，画颜色，圆形可能需要黄色黑色白色蓝色等等，矩形也可能需要黄色黑色白色蓝色等等，这种如果单纯的使用继承就不太灵活，可以使用桥接模式，把图形种类当作抽象部分，画颜色当作实现部分，使用组合的方式将抽象部分和实现部分分离



# 建造者模式

用于构建一个复杂的大的对象，一个复杂的对象通常需要一步步才可以构建完成，建造者模式强调的是一步步创建对象，并通过相同的构建过程可以获得不同的结果对象，一般来说建造者对象不是直接返回的，与抽象工厂方法区别是抽象工厂方法用于创建多个系列的对象，而建造者模式强调一步步构建对象，并且构建步骤固定，举例：想要构建一个老师类的对象，老师有第一技能和第二技能，第一技能是数学就代表是数学老师，第一技能是英语就代表是语文老师，构造一个老师对象需要先设定老师的第一技能再设定老师的第二技能，强调一步步设定技能，将这一步步的构建过程可以抽象出建造者模式。

# 设计原则



## 单一职责原则

就是一个类而言，应该仅有一个引起它变化的原因

一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会消弱或抑制这个类完成其它职责的能力，这种耦合会导致脆弱的设计，当变化发送时，设计会遭受意想不到的破坏



## 开放封闭原则

无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化

我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难

开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要



依赖倒置原则

针对接口编程，依赖于抽象而不依赖于具体，抽象(稳定)不应依赖于实现细节(变化)，实现细节应该依赖于抽象，因为稳定态如果依赖于变化态则会变成不稳定态。



接口隔离原则：接口最小化且完备，尽量少 public 来减少对外交互，只把外部需要的方法暴露出来。

最少知道原则：一个实体应该尽可能少的与其他实体发生相互作用。

