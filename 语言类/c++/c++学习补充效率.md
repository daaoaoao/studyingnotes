c++中的拷贝构造函数调用时机通常有三种情况

使用一个已经创建完毕的对象来初始化一个新对象

值传递的方式给函数参数传值

以值方式返回局部对象



构造函数调用规则

默认情况下，c++编译器至少给出一个类添加三个函数

默认构造函数（无参，函数体为空）

默认析构函数（无参，函数体为空）

默认拷贝构造函数，对属性进行值拷贝



构造函数调用规则如下

有用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造

用户定义拷贝构造函数，c++不会提供其它构造函数



浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请空间，进行拷贝操作



this指针

c++通过提供特殊的对象指针，this指针

this指针指向被调用的成员函数所属的的对象，this指针式隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可

this指针用途：

当形参和成员变量同名是，可以用this指针来去区分

在类的非静态成员函数中返回对象本身，可以使用return *this、







# new和make_shared区别



先new然后赋值的方式，会导致内存碎片化

make_shared的方法分配内存，不会导致内存产生过多的碎片



通过①的方式，是先在堆上分配一块内存，然后在堆上再建一个智能指针控制块，这两个东西是不连续的，会造成内存碎片化

通过②的方式，是直接在堆上新建一块足够大的内存，其中包含两部分，上面是内存（用来使用），下面是控制块（包含引用计数），然后用A的构造函数去初始化分配的内存（分配一块内存的步骤：先分配内存，再进分配的内存调用构造函数进行构造，构造完毕才能使用）





使用好的库 符合编码的

减少内存分配和复制

移除计算

使用更好的数据结构

提高并发性

优化内存管理



内存访问并非以字节为单位

当C++获取一个多字节类型的数据，构成数据的字节可能跨越了两个物理内存字，非对齐的内存访问



内存字分为大端和小端

字节序只是 C++ 不能指定 int 中位的存储方式或是设置联合体中的一个字 段会如何影响其他字段的原因之一。所编写的程序可以工作于一类计算机上，却在另一类 计算机上崩溃，原因也在于字节序



内存容量有限



在处理器中，访问内存的性能开销远比其他操作的性能开销大。 

非对齐访问所需的时间是所有字节都在同一个字中时的两倍。 

访问频繁使用的内存地址的速度比访问非频繁使用的内存地址的速度快。 

 访问相邻地址的内存的速度比访问互相远隔的地址的内存快。 

 由于高速缓存的存在，一个函数运行于整个程序的上下文中时的执行速度可能比运行于 测试套件中时更慢。 

 访问线程间共享的数据比访问非共享的数据要慢很多。 

计算比做决定快。 

每个程序都会与其他程序竞争计算机资源。 

 如果一个程序必须在启动时执行或是在负载高峰期时执行，那么在测量性能时必须加载 负载。 

 每一次赋值、函数参数的初始化和函数返回值都会调用一次构造函数，这个函数可能隐 藏了大量的未知代码。 

 有些语句隐藏了大量的计算。从语句的外表上看不出语句的性能开销会有多大。 • 当并发线程共享数据时，同步代码降低了并发量



测量性能

做出可测试的预测并记录预测

记录代码修改

可以计算一条c++语句对内存的读写次数，可以估算出一条c++语句的性能开销



字符串是动态分配的，动态分配内存耗时耗力



# 尽可能使用const

const定义一个变量和修饰类的成员变量

const在修饰变量时，对于普通变量其含义很简单就是常量。而对于指针的话根据const修饰的位置分为顶层const和底层const，具体使用哪种可以根据实际需求而定。
  const修饰成员函数时，其表示该成员函数可作用于const对象上并且返回的对象是const，这对有些场景很重要（有些场景用户需要明确调用函数之后不会改变对象本身的状态）。但同时带来一个问题，如何定义对象的状态不变，可能的概念有：

- bitwise constness（physical constness）：不修改对象本身的每一块内存，即不修改对象的每个成员变量即可。但是有时也会出现符合bitwise constness但是对象的行为确实非const的情况。比如对象拥有一个指向上下文环境对象的指针，
- logical constness（conceptual constness）：可以修改对象的内容，但是只有使用类的端检测不出该情况时才如此。

  一般比较好的做法是实现const和non-const的成员函数，但是这样又会造成代码重复，可以在non-const中调用const的实现减少代码重复，但是需要对传入的对象进行const化，并将const实现的返回值const化。





编译器对模板做了特殊处理，如果函数不是内联函数，那可以有两种处理方式：

1. 链接时随机选择一个定义，其它的丢弃掉
2. 编译器会把函数的定义单独提出来，提到单独一个文件中，对此文件单独编译，就不会出现重复定义的问题。



# const 和constexpr区别

const是对变量的一个修饰，只能被初始化，而不能修改



constexpr 可以用来修饰变量，函数和构造函数

编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。





破釜沉舟

Burn one's own boat to cut off all means of retreat
